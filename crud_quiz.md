CRUD Quiz
Use the solution to this afternoon's Property Tracker lab to answer the following questions. Please write your answers under each question, push the file to GitHub, and submit in the usual way.

MVP Questions
In our Property Tracker application:

Q1. Where are we instantiating instances of the Property class?
>> We do this under the def initialize(option). 

Q2. Where are we defining the SQL that enables us to save the ruby Property object into the database?
>> This is defined under the def save()

Q3. In console.rb, which lines modify the database?
>> Lines 4, 13, 15, 22, 24, 33

Q4. Why do we not define the id of a Property object at the point we instantiate it (‘new it up’)?
>> Because we want the database to do that for us.

Q5. Where and how do we assign the id (that is generated by the database) to the ruby Property object?
>> To the def save() method by this line. @id = db.exec_prepared("save", values)[0]["id"].to_i

Q6. Why do we put a guard (an if clause) on the @id attribute in the constructor?
>> 

Q7. Why are some of the CRUD actions represented by instance methods, and others by class methods?
>> We use Class Method when we're targeting everything on the database, where as Instances are used to target specific object that pre-exist.

Q8. What type of data structure is returned by calls to db.exec_prepared()? In the save method, how do we access the id from the returned data structure? 
>> The call returns an array in hashes, and we access the id by using [0]["id]

Q9. Why do we use prepared statements when performing database operations?
>> To guard against sql injection attacks.

Extension Questions
Look at the find_by_id and find_by_address methods in the Property class.

Q10. What do they take in as their arguments?
>> Find_by_id takes an INT while find_by_address takes takes a STRING.

Q11. What are their return values?
>> They'll return instances accordingly, else nothing.